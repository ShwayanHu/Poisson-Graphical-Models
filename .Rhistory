# Check if this is better than the current maximum
if (logPost > bestLogPosterior) {
bestLogPosterior <- logPost
bestClass <- j
}
}
predictedLabels[i] <- bestClass
}
correctVec <- (predictedLabels == trueLabel)
numCorrect <- sum(correctVec)
numTest    <- length(correctVec)
accuracy   <- numCorrect / numTest
cat("Number of correct classifications =", numCorrect, "\n")
cat("Total test images =", numTest, "\n")
cat("Accuracy =", accuracy, "\n")
X <- as.matrix(yTrain[, 1:64])   # Training features
digit <- yTrain$id               # Training labels
alpha <- rep(1, 64)             # Dirichlet(1,...,1)
classPrior <- prop.table(table(digit))  # a named vector, e.g. "0" "1" "2" ...
posteriorMeans <- list()
for (j in 0:9) {
Xj <- X[digit == j, , drop = FALSE]
c_j <- colSums(Xj)
postMean_j <- (alpha + c_j) / (sum(alpha) + sum(c_j))
posteriorMeans[[as.character(j)]] <- postMean_j
}
View(posteriorMeans)
Xtest <- as.matrix(yTest[, 1:64])
trueLabel <- yTest$id  # actual digit for test images
predictedLabels <- numeric(nrow(Xtest))  # to store predictions
for (i in seq_len(nrow(Xtest))) {
# Current test image's 64-dim block counts
x_i <- Xtest[i, ]
# We will compute log-likelihood + log-prior for each j
# dmultinom(..., log=TRUE) uses the formula for the multinomial pmf in log scale
bestLogPosterior <- -Inf
bestClass <- NA
for (j in 0:9) {
pj <- classPrior[as.character(j)]   # p(j) from training
# Posterior-mean-based pi^(j)
pi_j <- posteriorMeans[[as.character(j)]]
# log p(x_i | pi_j)
logLike <- dmultinom(x = x_i,
size = sum(x_i),
prob = pi_j,
log = TRUE)
# Add log p(j)
logPost <- logLike + log(pj)
# Check if this is better than the current maximum
if (logPost > bestLogPosterior) {
bestLogPosterior <- logPost
bestClass <- j
}
}
predictedLabels[i] <- bestClass
}
correctVec <- (predictedLabels == trueLabel)
numCorrect <- sum(correctVec)
numTest    <- length(correctVec)
accuracy   <- numCorrect / numTest
cat("Number of correct classifications =", numCorrect, "\n")
cat("Total test images =", numTest, "\n")
cat("Accuracy =", accuracy, "\n")
X <- as.matrix(yTrain[, 1:64])   # Training features
digit <- yTrain$id               # Training labels
alpha <- rep(1, 64)             # Dirichlet(1,...,1)
classPrior <- prop.table(table(digit))  # a named vector, e.g. "0" "1" "2" ...
posteriorMeans <- list()
for (j in 0:9) {
Xj <- X[digit == j, , drop = FALSE]
c_j <- colSums(Xj)
postMean_j <- (alpha + c_j) / (sum(alpha) + sum(c_j))
posteriorMeans[[as.character(j)]] <- postMean_j
}
alpha <- 1; beta <- 1
a_post <- alpha + 7
b_post <- beta + 3
mean_theta <- a_post / (a_post + b_post)
ci_theta <- qbeta(c(0.025, 0.975), a_post, b_post)
cat("Posterior mean of theta =", mean_theta, "\n")
cat("95% posterior interval of theta =",
sprintf("[%.3f, %.3f]", ci_theta[1], ci_theta[2]), "\n")
set.seed(123)
N <- 100000
theta_post <- rbeta(N, a_post, b_post)
gamma_post <- log(theta_post / (1 - theta_post))
mean_gamma <- mean(gamma_post)
ci_gamma <- quantile(gamma_post, probs = c(0.025, 0.975))
cat("Posterior mean of gamma =", mean_gamma, "\n")
cat("95% posterior interval of gamma =",
sprintf("[%.3f, %.3f]", ci_gamma[1], ci_gamma[2]), "\n")
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
y_obs <- c(0,3,0,1,5,2,0,4,1,1)
n <- length(y_obs)            # n=10
t_obs <- mean(y_obs)/sd(y_obs)
t_obs
log_post_unnormalized <- function(theta) {
if (theta <= 0) return(-Inf)
log_prior_part1 <- log(0.1) + log(4)   + (-4 * theta)
log_prior_part2 <- log(0.9) + (-lgamma(8)) + 7*log(theta) + (-theta)
lp1 <- log_prior_part1
lp2 <- log_prior_part2
log_prior <- if (lp1>lp2) {
lp1 + log1p(exp(lp2 - lp1))  # log1p(x)=log(1+x)
} else {
lp2 + log1p(exp(lp1 - lp2))
}
sum_y <- sum(y_obs)
log_lik <- -n*theta + sum_y*log(theta)
return(log_prior + log_lik)
}
# 接受-拒绝抽样一个小函数:
rtheta_posterior <- function(n_draws, max_val=50) {
draws <- numeric(n_draws)
count <- 0
while (count < n_draws) {
proposal <- rgamma(1, shape=25, rate=1)
lp_post_prop <- log_post_unnormalized(proposal)
c <- -5
if ( runif(1) < exp(lp_post_prop - c) ) {
count <- count + 1
draws[count] <- proposal
}
}
draws
}
theta_samp <- rtheta_posterior(5000)
S <- 5000
t_s <- numeric(S)
for (s in 1:S) {
th <- theta_samp[s]
y_new <- rpois(n, lambda=th)
sd_new <- sd(y_new)
if (sd_new==0) {
t_s[s] <- NA
} else {
t_s[s] <- mean(y_new) / sd_new
}
}
set.seed(123)
y_obs <- c(0,3,0,1,5,2,0,4,1,1)
n     <- length(y_obs)            # 10
sum_y <- sum(y_obs)               # 17
t_obs <- mean(y_obs)/sd(y_obs)
t_obs
library(gsl)
set.seed(123)
y_obs <- c(0,3,0,1,5,2,0,4,1,1)
n     <- length(y_obs)            # 10
sum_y <- sum(y_obs)               # 17
t_obs <- mean(y_obs)/sd(y_obs)
t_obs
val1 <- 0.4 * gamma(18)/ (14^18)
val2 <- 0.9 * (gamma(25)/gamma(8)) / (11^25)
w1_star <- val1/(val1+val2)
w2_star <- 1 - w1_star
w1_star; w2_star
S <- 5000
theta_samp <- numeric(S)
comp_label <- rbinom(S, size=1, prob=w1_star)
idx1 <- which(comp_label==1)
idx2 <- which(comp_label==0)
theta_samp[idx1] <- rgamma(length(idx1), shape=18, rate=14)
theta_samp[idx2] <- rgamma(length(idx2), shape=25, rate=11)
t_s <- numeric(S)
for(s in seq_len(S)){
th <- theta_samp[s]
y_new <- rpois(n, lambda=th)
sd_new <- sd(y_new)
t_s[s]  <- if(sd_new>0) mean(y_new)/sd_new else NA
}
hist(t_s, probability=TRUE, col="lightgray",
main="Posterior Predictive of T",
xlab="t^(s) = mean(y_new)/sd(y_new)")
abline(v=t_obs, col="red", lwd=2)
stents <- readr::read_csv("https://sta602-sp25.github.io/data/stent365.csv")
View(stents)
set.seed(123)
y_obs <- c(0,3,0,1,5,2,0,4,1,1)
n     <- length(y_obs)
sum_y <- sum(y_obs)
t_obs <- mean(y_obs)/sd(y_obs)
val1 <- 0.4 * gamma(18)/ (14^18)
val2 <- 0.9 * (gamma(25)/gamma(8)) / (11^25)
w1_star <- val1/(val1+val2)
w2_star <- 1 - w1_star
S <- 5000
theta_samp <- numeric(S)
comp_label <- rbinom(S, size=1, prob=w1_star)
idx1 <- which(comp_label==1)
idx2 <- which(comp_label==0)
theta_samp[idx1] <- rgamma(length(idx1), shape=18, rate=14)
theta_samp[idx2] <- rgamma(length(idx2), shape=25, rate=11)
t_s <- numeric(S)
for(s in seq_len(S)){
th <- theta_samp[s]
y_new <- rpois(n, lambda=th)
sd_new <- sd(y_new)
t_s[s]  <- if(sd_new>0) mean(y_new)/sd_new else NA
}
hist(t_s, probability=TRUE, col="lightgray",
main="Posterior Predictive of T",
xlab="t^(s) = mean(y_new)/sd(y_new)")
abline(v=t_obs, col="red", lwd=2)
library(dplyr)
library(ggplot2)
stents2 <- stents %>%
mutate(
stroke_ind = ifelse(outcome=="stroke",1,0),
stent_ind  = ifelse(group=="treatment",1,0)
)
treatment_data <- filter(stents2, stent_ind==1)
control_data   <- filter(stents2, stent_ind==0)
n_t  <- nrow(treatment_data)
x_t  <- sum(treatment_data$stroke_ind)
n_c  <- nrow(control_data)
x_c  <- sum(control_data$stroke_ind)
alpha_t <- 1
beta_t  <- 1
post_alpha_t <- alpha_t + x_t
post_beta_t  <- beta_t  + (n_t - x_t)
alpha_c <- 1
beta_c  <- 1
post_alpha_c <- alpha_c + x_c
post_beta_c  <- beta_c  + (n_c - x_c)
S <- 5000
theta_t_samp <- rbeta(S, shape1=post_alpha_t, shape2=post_beta_t)
theta_c_samp <- rbeta(S, shape1=post_alpha_c, shape2=post_beta_c)
RR_samp <- theta_t_samp / theta_c_samp
mean_rr <- mean(RR_samp)
ci_95   <- quantile(RR_samp, probs=c(0.025, 0.975))
cat("Posterior mean of relative risk =", mean_rr, "\n")
cat("95% posterior credible interval = [",
ci_95[1], ", ", ci_95[2], "]\n")
df_rr <- data.frame(rr=RR_samp)
ggplot(df_rr, aes(rr)) +
geom_histogram(aes(y=..density..), bins=40,
color="white", fill="skyblue") +
geom_vline(xintercept=c(ci_95[1], ci_95[2]),
col="red", linetype="dashed") +
geom_vline(xintercept=mean_rr, col="blue", size=1) +
geom_vline(xintercept=1, col="black") +
labs(
x="Relative Risk (theta_t / theta_c)",
y="Posterior Density",
title="Posterior distribution of relative risk"
)
df_rr <- data.frame(rr=RR_samp)
ggplot(df_rr, aes(rr)) +
geom_histogram(aes(y=..density..), bins=40,
color="white", fill="skyblue") +
geom_vline(xintercept=c(ci_95[1], ci_95[2]),
col="red", linetype="dashed") +
geom_vline(xintercept=mean_rr, col="blue", size=1) +
geom_vline(xintercept=1, col="black") +
labs(
x="Relative Risk (theta_t / theta_c)",
y="Posterior Density",
title="Posterior distribution of relative risk"
)
library(dplyr)
library(ggplot2)
stents2 <- stents %>%
mutate(
stroke_ind = ifelse(outcome=="stroke",1,0),
stent_ind  = ifelse(group=="treatment",1,0)
)
treatment_data <- filter(stents2, stent_ind==1)
control_data   <- filter(stents2, stent_ind==0)
n_t  <- nrow(treatment_data)
x_t  <- sum(treatment_data$stroke_ind)
n_c  <- nrow(control_data)
x_c  <- sum(control_data$stroke_ind)
alpha_t <- 1
beta_t  <- 1
post_alpha_t <- alpha_t + x_t
post_beta_t  <- beta_t  + (n_t - x_t)
alpha_c <- 1
beta_c  <- 1
post_alpha_c <- alpha_c + x_c
post_beta_c  <- beta_c  + (n_c - x_c)
S <- 5000
theta_t_samp <- rbeta(S, shape1=post_alpha_t, shape2=post_beta_t)
theta_c_samp <- rbeta(S, shape1=post_alpha_c, shape2=post_beta_c)
RR_samp <- theta_t_samp / theta_c_samp
mean_rr <- mean(RR_samp)
ci_95   <- quantile(RR_samp, probs=c(0.025, 0.975))
cat("Posterior mean of relative risk =", mean_rr, "\n")
cat("95% posterior credible interval = [",
ci_95[1], ", ", ci_95[2], "]\n")
df_rr <- data.frame(rr=RR_samp)
ggplot(df_rr, aes(rr)) +
geom_histogram(aes(y=..density..), bins=40,
color="white", fill="skyblue") +
geom_vline(xintercept=c(ci_95[1], ci_95[2]),
col="red", linetype="dashed") +
geom_vline(xintercept=mean_rr, col="blue", size=1) +
geom_vline(xintercept=1, col="black") +
labs(
x="Relative Risk (theta_t / theta_c)",
y="Posterior Density",
title="Posterior distribution of relative risk"
)
df_rr <- data.frame(rr=RR_samp)
ggplot(df_rr, aes(rr)) +
geom_histogram(aes(y=..density..), bins=40,
color="white", fill="skyblue") +
geom_vline(xintercept=c(ci_95[1], ci_95[2]),
col="red", linetype="dashed") +
geom_vline(xintercept=mean_rr, col="blue", size=1) +
labs(
x="Relative Risk (theta_t / theta_c)",
y="Posterior Density",
title="Posterior distribution of relative risk"
)
library(dplyr)
library(ggplot2)
stents2 <- stents %>%
mutate(
stroke_ind = ifelse(outcome=="stroke",1,0),
stent_ind  = ifelse(group=="treatment",1,0)
)
treatment_data <- filter(stents2, stent_ind==1)
control_data   <- filter(stents2, stent_ind==0)
n_t  <- nrow(treatment_data)
x_t  <- sum(treatment_data$stroke_ind)
n_c  <- nrow(control_data)
x_c  <- sum(control_data$stroke_ind)
alpha_t <- 1
beta_t  <- 1
post_alpha_t <- alpha_t + x_t
post_beta_t  <- beta_t  + (n_t - x_t)
alpha_c <- 1
beta_c  <- 1
post_alpha_c <- alpha_c + x_c
post_beta_c  <- beta_c  + (n_c - x_c)
S <- 5000
theta_t_samp <- rbeta(S, shape1=post_alpha_t, shape2=post_beta_t)
theta_c_samp <- rbeta(S, shape1=post_alpha_c, shape2=post_beta_c)
RR_samp <- theta_t_samp / theta_c_samp
mean_rr <- mean(RR_samp)
ci_95   <- quantile(RR_samp, probs=c(0.025, 0.975))
cat("Posterior mean of relative risk =", mean_rr, "\n")
cat("95% posterior credible interval = [",
ci_95[1], ", ", ci_95[2], "]\n")
df_rr <- data.frame(rr=RR_samp)
ggplot(df_rr, aes(rr)) +
geom_histogram(aes(y=..density..), bins=40,
color="white", fill="skyblue") +
geom_vline(xintercept=c(ci_95[1], ci_95[2]),
col="red", linetype="dashed") +
geom_vline(xintercept=mean_rr, col="blue", size=1) +
geom_vline(xintercept=1, col="black") +
labs(
x="Relative Risk (theta_t / theta_c)",
y="Posterior Density",
title="Posterior distribution of relative risk"
)
install.packages("C:/Users/30604/Downloads/XMRF_1.0.tar.gz", repos = NULL, type="source")
install.packages(c("glmnet", "snowfall"))
install.packages("C:/Users/30604/Downloads/XMRF_1.0.tar.gz", repos = NULL, type = "source")
knitr::opts_chunk$set(echo = TRUE)
# ====== Environment set-up =======
library(XMRF)
library(pROC)
library(verification)
library(glmnet)       # For penalized GLMs
library(igraph)       # Network generation and analysis
library(ggplot2)
library(gridExtra)
library(grid)
## ===== Set seed =====
set.seed(42)
## ===== Set work directory =====
setwd("C:/Users/30604/Desktop/Duke/STAT_841/Poisson-Graphical-Models")
purrr::walk(list.files("./helper_fns/", pattern = "*.R$", full.names=TRUE), source,.GlobalEnv)
data("brcadat")
brca <- t(processSeq(t(brcadat), PercentGenes=1)) # n = 445, p = 353
n <- ncol(brca)
p <- nrow(brca)
X <- t(as.matrix(brca))
# ===== Fit QPGM and SPGM with optim() =====
#THETA_qpgm <- fit_Quadratic_Poisson_Graphical_Model_optim(X = X, lambda = 1e3)
THETA_spgm <- fit_Sublinear_Poisson_Graphical_Model_optim(X = X, lambda = 1e3)
theta_mat <- abs(THETA_spgm)
df <- melt(theta_mat)
library(reshape2)
library(ggplot2)
theta_mat <- abs(THETA_spgm)
df <- melt(theta_mat)
colnames(df) <- c("Var1", "Var2", "value")
ggplot(df, aes(x = Var2, y = Var1, fill = value)) +
geom_tile(color = "white", size = 0.1) +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "SPGM θ Matrix (TCGA miRNA Data)", x = "", y = "") +
coord_fixed() +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6),
axis.text.y = element_text(size = 6),
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "right")
summary(THETA_spgm)
mean(THETA_spgm)
library(reshape2)
library(ggplot2)
theta_mat <- abs(THETA_spgm*1000)
df <- melt(theta_mat)
colnames(df) <- c("Var1", "Var2", "value")
ggplot(df, aes(x = Var2, y = Var1, fill = value)) +
geom_tile(color = "white", size = 0.1) +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "SPGM θ Matrix (TCGA miRNA Data)", x = "", y = "") +
coord_fixed() +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6),
axis.text.y = element_text(size = 6),
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "right")
View(THETA_spgm)
library(reshape2)
library(ggplot2)
theta_mat <- abs(THETA_spgm*10000)
df <- melt(theta_mat)
colnames(df) <- c("Var1", "Var2", "value")
ggplot(df, aes(x = Var2, y = Var1, fill = value)) +
geom_tile(color = "white", size = 0.1) +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "SPGM θ Matrix (TCGA miRNA Data)", x = "", y = "") +
coord_fixed() +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6),
axis.text.y = element_text(size = 6),
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "right")
mean(df)
means(df)
mean(theta_mat)
mean(theta_mat>100)
mean(theta_mat>1000)
library(reshape2)
library(ggplot2)
theta_mat <- log(abs(THETA_spgm*10000))
df <- melt(theta_mat)
colnames(df) <- c("Var1", "Var2", "value")
ggplot(df, aes(x = Var2, y = Var1, fill = value)) +
geom_tile(color = "white", size = 0.1) +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "SPGM θ Matrix (TCGA miRNA Data)", x = "", y = "") +
coord_fixed() +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6),
axis.text.y = element_text(size = 6),
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "right")
library(reshape2)
library(ggplot2)
mat <- abs(THETA_spgm)
df <- melt(mat)
# 绘制热图（与之前风格一致）
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "white", high = "black") +
labs(title = "SPGM: Fitted θ on TCGA miRNA Data", x = NULL, y = NULL) +
theme_minimal(base_size = 14) +
theme(axis.text = element_text(size = 10),
axis.ticks = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5, face = "bold", size = 12))
THETA_spgm_T <- ifelse(THETA_spgm>100,100,THETA_spgm)
THETA_spgm_T <- ifelse(THETA_spgm>100,100,THETA_spgm)
mat <- abs(THETA_spgm_T)
df <- melt(mat)
# 绘制热图（与之前风格一致）
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "white", high = "black") +
labs(title = "SPGM: Fitted θ on TCGA miRNA Data", x = NULL, y = NULL) +
theme_minimal(base_size = 14) +
theme(axis.text = element_text(size = 10),
axis.ticks = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5, face = "bold", size = 12))
THETA_spgm_T <- pmin(abs(THETA_spgm), 100)
# 转换为长数据格式
df <- melt(THETA_spgm_T)
# 绘图：与之前风格统一（白-黑，去图例）
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "white", high = "black") +
labs(title = "SPGM: Fitted θ on TCGA miRNA Data", x = NULL, y = NULL) +
theme_minimal(base_size = 14) +
theme(axis.text = element_text(size = 10),
axis.ticks = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5, face = "bold", size = 12))
library(reshape2)
library(ggplot2)
THETA_spgm_T <- log(pmin(abs(THETA_spgm), 100))
# 转换为长数据格式
df <- melt(THETA_spgm_T)
# 绘图：与之前风格统一（白-黑，去图例）
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "white", high = "black") +
labs(title = "SPGM: Fitted θ on TCGA miRNA Data", x = NULL, y = NULL) +
theme_minimal(base_size = 14) +
theme(axis.text = element_text(size = 10),
axis.ticks = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5, face = "bold", size = 12))
saveRDS(THETA_spgm, file = "THETA_spgm_result.rds")
